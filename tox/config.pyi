import argparse
import pluggy
import py
from py.path import LocalPath
from types import ModuleType
from typing import (
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    Optional,
    Pattern,
    Sequence,
    Set,
    Tuple,
    TypeVar,
    Match,
)

import tox
from tox.interpreters import InterpreterInfo, Interpreters

hookimpl: pluggy.HookimplMarker = ...
default_factors: Dict[str, str] = ...

from typing_extensions import Protocol

PostProcessVar = TypeVar("PostProcessVar")
PostProcess = Callable[["TestenvConfig", PostProcessVar], PostProcessVar]

class TestEnvAttr(Protocol):
    name: str = ...
    default: Any = ...
    help: str = ...
    type: str = ...

def get_plugin_manager(plugins: Sequence[ModuleType] = ...) -> pluggy.PluginManager: ...

class Parser:
    argparser: argparse.ArgumentParser = ...
    _testenv_attr: List[TestEnvAttr] = ...
    def __init__(self) -> None: ...
    def add_argument(self, *args: str, **kwargs: str) -> argparse.Action: ...
    def add_testenv_attribute(
        self,
        name: str,
        type: str,
        help: str,
        default: Optional[Any] = ...,
        postprocess: Optional[PostProcess] = ...,
    ) -> None: ...
    def add_testenv_attribute_obj(self, obj: TestEnvAttr) -> None: ...
    def _parse_args(self, args: Sequence[str]) -> argparse.Namespace: ...
    def _format_help(self) -> str: ...

class VenvAttribute:
    name: str = ...
    type: str = ...
    default: Any = ...
    help: str = ...
    postprocess: PostProcess = ...
    def __init__(
        self, name: str, type: str, default: Any, help: str, postprocess: PostProcess
    ) -> None: ...

class DepOption:
    name: str = ...
    type: str = ...
    help: str = ...
    default: Tuple = ...
    def postprocess(self, testenv_config: TestenvConfig, value: Sequence[str]) -> List[str]: ...
    def _replace_forced_dep(self, name: str, config: Config) -> str: ...
    @classmethod
    def _is_same_dep(cls, dep1: str, dep2: str) -> bool: ...

class PosargsOption:
    name: str = ...
    type: str = ...
    default: bool = ...
    help: str = ...
    def postprocess(self, testenv_config: TestenvConfig, value: bool) -> bool: ...

class InstallcmdOption:
    name: str = ...
    type: str = ...
    default: str = ...
    help: str = ...
    def postprocess(self, testenv_config: TestenvConfig, value: str) -> str: ...

def parseconfig(args: Sequence[str], plugins: Sequence[ModuleType] = ...) -> Config: ...
def feedback(msg: str, sysexit: bool = ...) -> None: ...
def get_version_info(pm: pluggy.PluginManager) -> str: ...

class SetenvDict:
    _DUMMY: object = ...
    definitions: Dict[str, str] = ...
    reader: SectionReader = ...
    resolved: Dict[str, str] = ...
    _lookupstack: List[str] = ...
    def __init__(self, definitions: Dict[str, str], reader: SectionReader) -> None: ...
    def __repr__(self) -> str: ...
    def __contains__(self, name: str) -> bool: ...
    def get(self, name: str, default: Optional[Any] = ...) -> str: ...
    def __getitem__(self, name: str) -> str: ...
    def keys(self) -> Iterable[str]: ...
    def __setitem__(self, name: str, value: str) -> None: ...

@tox.hookimpl  # type: ignore
def tox_addoption(parser: Parser) -> None: ...

class Config:
    invocationcwd: LocalPath = ...
    interpreters: Interpreters = ...
    pluginmanager: pluggy.PluginManager = ...
    option: argparse.Namespace = ...
    def __init__(
        self,
        pluginmanager: pluggy.PluginManager,
        option: argparse.Namespace,
        interpreters: Interpreters,
    ) -> None: ...
    _cfg: Any = ...
    _testenv_attr: List[TestEnvAttr] = ...

    toxinipath: LocalPath = ...
    toxinidir: LocalPath = ...
    toxworkdir: LocalPath = ...

    distdir: LocalPath = ...
    distshare: LocalPath = ...
    envconfigs: Dict[str, TestenvConfig] = ...

    envlist: List[str] = ...
    hashseed: str = ...
    homedir = LocalPath
    indexserver = Dict[str, "IndexServerConfig"]
    logdir: LocalPath = ...
    minversion: Optional[str] = ...
    sdistsrc: Optional[LocalPath] = ...
    setupdir: LocalPath = ...
    @property
    def homedir(self) -> str: ...

class TestenvConfig:
    envname: str = ...
    config: Config = ...
    factors: Set[str] = ...
    _reader: SectionReader = ...
    missing_subs: List = ...

    alwayscopy: bool = ...
    args_are_paths: bool = ...
    basepython: str = ...
    changedir: LocalPath = ...
    commands: List[List[str]] = ...
    deps: List[str] = ...
    description: str = ...
    downloadcache: Optional[LocalPath] = ...
    envbindir: LocalPath = ...
    envdir: LocalPath = ...
    envlogdir: LocalPath = ...
    envpython: LocalPath = ...
    envtmpdir: LocalPath = ...
    extras: List[str] = ...
    ignore_errors: bool = ...
    ignore_outcome: bool = ...
    install_command: List[str] = ...
    list_dependencies_command: List[str] = ...
    passenv: Set[str] = ...
    pip_pre: bool = ...
    platform: str = ...
    python_info: InterpreterInfo = ...
    recreate: bool = ...
    setenv: SetenvDict = ...
    sitepackages: bool = ...
    skip_install: bool = ...
    usedevelop: bool = ...
    whitelist_externals: List[str] = ...
    def __init__(
        self, envname: str, config: Config, factors: Set[str], reader: SectionReader
    ) -> None: ...
    def get_envbindir(self) -> LocalPath: ...
    @property
    def envbindir(self) -> LocalPath: ...
    @property
    def envpython(self) -> LocalPath: ...
    def get_envpython(self) -> LocalPath: ...
    def get_envsitepackagesdir(self) -> LocalPath: ...
    @property
    def python_info(self) -> InterpreterInfo: ...
    def getsupportedinterpreter(self) -> LocalPath: ...

testenvprefix: str = ...
def get_homedir() -> Optional[LocalPath]: ...
def make_hashseed() -> int: ...

class parseini:
    _cfg: py.iniconfig.IniConfig = ...
    config: Config = ...
    def __init__(self, config: Config, inipath: LocalPath) -> None: ...
    def _list_section_factors(self, section: str) -> Set[str]: ...
    def make_envconfig(
        self, name: str, section: str, subs: Dict[str, Any], config: Config, replace: bool = ...
    ) -> TestenvConfig: ...
    def _getenvdata(self, reader: SectionReader) -> Tuple[List[str], Set[str]]: ...

def _split_env(env: List[str]) -> List[str]: ...
def _is_negated_factor(factor: str) -> bool: ...
def _base_factor_name(factor: str) -> str: ...
def _split_factor_expr(expr: str) -> List[Tuple[Set[str], ...]]: ...
def _split_factor_expr_all(expr: str) -> List[Set[str]]: ...
def _expand_envstr(envstr: str) -> List[str]: ...

MapCat = TypeVar("MapCat")
def mapcat(f: Callable[[MapCat], MapCat], seq: Sequence[MapCat]) -> List[MapCat]: ...

class DepConfig:
    name: str = ...
    indexserver: Optional[IndexServerConfig] = ...
    def __init__(self, name: str, indexserver: Optional[IndexServerConfig] = ...) -> None: ...
    def __str__(self) -> str: ...
    __repr__: Callable[[], str] = ...

class IndexServerConfig:
    name: str = ...
    url: Optional[str] = ...
    def __init__(self, name: str, url: Optional[str] = ...) -> None: ...

is_section_substitution: Pattern = ...

class SectionReader:
    section_name: str = ...
    _cfg: py.iniconfig.IniConfig = ...
    fallbacksections: List[str] = ...
    factors: Sequence[str] = ...
    _subs: Dict[str, str] = ...
    _subststack: List[Tuple[str, str]] = ...
    posargs: Optional[Sequence[str]] = ...
    _setenv: SetenvDict
    def __init__(
        self,
        section_name: str,
        cfgparser: py.iniconfig.IniConfig,
        fallbacksections: Optional[List[str]] = ...,
        factors: Sequence[str] = ...,
        prefix: Optional[str] = ...,
    ) -> None: ...
    def get_environ_value(self, name: str) -> str: ...
    def addsubstitutions(self, _posargs: Optional[Sequence[str]] = ..., **kw: str) -> None: ...
    def getpath(self, name: str, defaultpath: str, replace: bool = ...) -> str: ...
    def getlist(self, name: str, sep: str = ...) -> List[str]: ...
    def getdict(
        self,
        name: str,
        default: Optional[Dict[str, str]] = ...,
        sep: str = ...,
        replace: bool = ...,
    ) -> Dict[str, str]: ...
    def getdict_setenv(
        self,
        name: str,
        default: Optional[Dict[str, str]] = ...,
        sep: str = ...,
        replace: bool = ...,
    ) -> SetenvDict: ...
    def _getdict(
        self, value: str, default: Optional[Dict[str, str]], sep: str, replace: bool = ...
    ) -> Dict[str, str]: ...
    def getbool(self, name: str, default: Optional[bool] = ..., replace: bool = ...) -> bool: ...
    def getargvlist(
        self, name: str, default: str = ..., replace: bool = ...
    ) -> List[List[str]]: ...
    def getargv(self, name: str, default: str = ..., replace: bool = ...) -> List[str]: ...
    def getstring(
        self, name: str, default: Optional[str] = ..., replace: bool = ..., crossonly: bool = ...
    ) -> str: ...
    def _apply_factors(self, s: str) -> str: ...
    def _replace(
        self,
        value: str,
        name: Optional[str] = ...,
        section_name: Optional[str] = ...,
        crossonly: bool = ...,
    ) -> str: ...

class Replacer:
    RE_ITEM_REF: Pattern = ...
    reader: SectionReader = ...
    crossonly: bool = ...
    def __init__(self, reader: SectionReader, crossonly: bool = ...) -> None: ...
    def do_replace(self, value: str) -> str: ...
    def _replace_match(self, match: Match) -> str: ...
    def _replace_env(self, match: Match) -> str: ...
    def _substitute_from_other_section(self, key: str) -> str: ...
    def _replace_substitution(self, match: Match) -> str: ...

class _ArgvlistReader:
    @classmethod
    def getargvlist(
        cls, reader: SectionReader, value: str, replace: bool = ...
    ) -> List[List[str]]: ...
    @classmethod
    def processcommand(
        cls, reader: SectionReader, command: str, replace: bool = ...
    ) -> List[str]: ...

class CommandParser:
    class State:
        word: str = ...
        depth: int = ...
        yield_words: List[str] = ...
        def __init__(self) -> None: ...
    command: str = ...
    def __init__(self, command: str) -> None: ...
    def words(self) -> List[str]: ...

def getcontextname() -> Optional[str]: ...
